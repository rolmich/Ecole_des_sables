"""
Logique d'assignation des participants aux bungalows.

R√®gles d'assignation:
1. Capacit√© de la chambre ne doit pas √™tre d√©pass√©e
2. Dur√©e du participant dans la chambre = dur√©e de son stage
3. Tous les participants dans une chambre doivent appartenir au m√™me stage
4. Pas de mixit√© homme/femme dans la m√™me chambre
5. Gestion des chevauchements de p√©riodes
"""

from datetime import date
from typing import Tuple, List, Dict, Optional
from .models import Participant, Bungalow, Stage


class AssignmentError(Exception):
    """Exception personnalis√©e pour les erreurs d'assignation."""
    
    def __init__(self, message: str, code: str = None, details: dict = None):
        self.message = message
        self.code = code
        self.details = details or {}
        super().__init__(self.message)


def check_date_overlap(start1: date, end1: date, start2: date, end2: date) -> bool:
    """
    V√©rifie si deux p√©riodes se chevauchent.
    
    Exemples:
    - [11-13] et [14-16] ‚Üí False (pas de chevauchement)
    - [11-13] et [12-15] ‚Üí True (chevauchement)
    - [11-15] et [12-14] ‚Üí True (chevauchement)
    """
    return start1 <= end2 and end1 >= start2


def get_participant_assignment_dates(participant: Participant, stage: Stage) -> Tuple[date, date]:
    """
    Retourne les dates d'assignation pour un participant bas√©es sur son stage.
    """
    return stage.start_date, stage.end_date


def validate_assignment(
    participant: Participant,
    bungalow: Bungalow,
    bed_id: str,
    stage: Stage
) -> Tuple[bool, Optional[str], Optional[Dict]]:
    """
    Valide qu'un participant peut √™tre assign√© √† un bungalow.
    
    Returns:
        Tuple[bool, Optional[str], Optional[Dict]]: 
        (is_valid, error_message, error_details)
    """
    
    # R√®gle 1: V√©rifier que le lit existe
    bed_found = False
    for bed in bungalow.beds:
        if bed.get('id') == bed_id:
            bed_found = True
            break
    
    if not bed_found:
        available = [b.get('id') for b in bungalow.beds]
        return False, f"‚ùå LIT INTROUVABLE: Le lit '{bed_id}' n'existe pas dans le bungalow {bungalow.name}. Les lits disponibles dans ce bungalow sont: {', '.join(available)}. Veuillez choisir un lit valide.", {
            'code': 'BED_NOT_FOUND',
            'bungalow': bungalow.name,
            'bed_id': bed_id,
            'available_beds': available
        }
    
    # R√®gle 2: V√©rifier que le participant appartient au stage
    if stage not in participant.stages.all():
        participant_stages = [s.name for s in participant.stages.all()]
        if len(participant_stages) == 0:
            return False, f"‚ö†Ô∏è PAS DE STAGE: {participant.full_name} n'est inscrit √† AUCUN stage. Vous devez d'abord inscrire cette personne √† un stage de formation avant de pouvoir lui attribuer une chambre.", {
                'code': 'PARTICIPANT_NOT_IN_STAGE',
                'participant': participant.full_name,
                'stage': stage.name,
                'participant_stages': []
            }
        else:
            return False, f"‚ö†Ô∏è MAUVAIS STAGE: {participant.full_name} n'est PAS inscrit au stage '{stage.name}'. Cette personne est inscrite aux stages: {', '.join(participant_stages)}. Vous devez l'assigner pour un de SES stages, pas pour un autre stage.", {
                'code': 'PARTICIPANT_NOT_IN_STAGE',
                'participant': participant.full_name,
                'stage_requested': stage.name,
                'participant_stages': participant_stages
            }
    
    # Obtenir les dates d'assignation bas√©es sur le stage
    assignment_start, assignment_end = get_participant_assignment_dates(participant, stage)
    
    # R√®gle 3: V√©rifier les participants d√©j√† assign√©s √† ce bungalow
    existing_assignments = Participant.objects.filter(
        assigned_bungalow=bungalow
    ).exclude(id=participant.id)
    
    # R√®gle 4: V√©rifier la mixit√© (pas homme/femme ensemble)
    for existing in existing_assignments:
        # V√©rifier s'il y a chevauchement de dates
        if existing.assignment_start_date and existing.assignment_end_date:
            if check_date_overlap(
                assignment_start, assignment_end,
                existing.assignment_start_date, existing.assignment_end_date
            ):
                # Il y a chevauchement, v√©rifier la mixit√©
                if existing.gender != participant.gender:
                    return False, f"üö´ CHAMBRES NON-MIXTES: Ce bungalow {bungalow.name} est occup√© par {existing.full_name} ({existing.get_gender_display()}) du {existing.assignment_start_date.strftime('%d/%m')} au {existing.assignment_end_date.strftime('%d/%m')}. Vous ne pouvez PAS ajouter {participant.full_name} ({participant.get_gender_display()}) car LES HOMMES ET LES FEMMES NE PEUVENT PAS PARTAGER LA M√äME CHAMBRE. Veuillez choisir un autre bungalow r√©serv√© aux {participant.get_gender_display()}s.", {
                        'code': 'GENDER_MIXING_NOT_ALLOWED',
                        'bungalow': bungalow.name,
                        'existing_participant': existing.full_name,
                        'existing_gender': existing.get_gender_display(),
                        'new_participant': participant.full_name,
                        'new_gender': participant.get_gender_display(),
                        'overlap_period': {
                            'existing': f"{existing.assignment_start_date} - {existing.assignment_end_date}",
                            'requested': f"{assignment_start} - {assignment_end}"
                        }
                    }
    
    # R√®gle 5: V√©rifier que tous les participants appartiennent au m√™me stage
    for existing in existing_assignments:
        if existing.assignment_start_date and existing.assignment_end_date:
            if check_date_overlap(
                assignment_start, assignment_end,
                existing.assignment_start_date, existing.assignment_end_date
            ):
                # V√©rifier que c'est le m√™me stage
                existing_stages = existing.stages.all()
                
                # Trouver le stage de l'assignation existante
                # On suppose que l'assignation est pour le stage correspondant aux dates
                existing_stage = None
                for es in existing_stages:
                    if (es.start_date == existing.assignment_start_date and 
                        es.end_date == existing.assignment_end_date):
                        existing_stage = es
                        break
                
                if existing_stage and existing_stage != stage:
                    return False, f"üö´ STAGES DIFF√âRENTS: Ce bungalow {bungalow.name} est d√©j√† r√©serv√© pour le stage '{existing_stage.name}' (avec {existing.full_name}) du {existing.assignment_start_date.strftime('%d/%m')} au {existing.assignment_end_date.strftime('%d/%m')}. Vous ne pouvez PAS m√©langer des participants de STAGES DIFF√âRENTS dans la m√™me chambre pendant la m√™me p√©riode. Le stage '{stage.name}' doit avoir ses propres chambres s√©par√©es.", {
                        'code': 'DIFFERENT_STAGES_NOT_ALLOWED',
                        'bungalow': bungalow.name,
                        'existing_participant': existing.full_name,
                        'existing_stage': existing_stage.name if existing_stage else 'Inconnu',
                        'new_stage': stage.name
                    }
    
    # R√®gle 6: V√©rifier la capacit√© du bungalow pour cette p√©riode
    # Compter combien de lits sont occup√©s pendant la p√©riode demand√©e
    occupied_beds_during_period = set()
    
    for existing in existing_assignments:
        if existing.assignment_start_date and existing.assignment_end_date and existing.assigned_bed:
            if check_date_overlap(
                assignment_start, assignment_end,
                existing.assignment_start_date, existing.assignment_end_date
            ):
                occupied_beds_during_period.add(existing.assigned_bed)
    
    # V√©rifier si le lit demand√© est d√©j√† occup√© pendant cette p√©riode
    if bed_id in occupied_beds_during_period:
        conflicting = existing_assignments.filter(
            assigned_bed=bed_id,
            assignment_start_date__lte=assignment_end,
            assignment_end_date__gte=assignment_start
        ).first()
        
        return False, f"üõèÔ∏è LIT D√âJ√Ä OCCUP√â: Ce lit ({bed_id}) du bungalow {bungalow.name} est d√©j√† r√©serv√© par {conflicting.full_name} du {conflicting.assignment_start_date.strftime('%d/%m/%Y')} au {conflicting.assignment_end_date.strftime('%d/%m/%Y')}. Les dates se chevauchent avec celles de {participant.full_name} ({assignment_start.strftime('%d/%m/%Y')} au {assignment_end.strftime('%d/%m/%Y')}). Un lit ne peut pas √™tre occup√© par deux personnes en m√™me temps. Veuillez choisir un AUTRE LIT disponible.", {
            'code': 'BED_OCCUPIED_OVERLAP',
            'bungalow': bungalow.name,
            'bed_id': bed_id,
            'occupied_by': conflicting.full_name,
            'occupied_period': f"{conflicting.assignment_start_date.strftime('%d/%m')} - {conflicting.assignment_end_date.strftime('%d/%m')}",
            'requested_period': f"{assignment_start.strftime('%d/%m')} - {assignment_end.strftime('%d/%m')}"
        }
    
    # V√©rifier que le nombre total de lits occup√©s ne d√©passe pas la capacit√©
    if len(occupied_beds_during_period) >= bungalow.capacity:
        return False, f"üè† BUNGALOW COMPLET: Le bungalow {bungalow.name} est COMPLET pour la p√©riode du {assignment_start.strftime('%d/%m/%Y')} au {assignment_end.strftime('%d/%m/%Y')}. Il a {bungalow.capacity} lits et TOUS sont d√©j√† r√©serv√©s ({len(occupied_beds_during_period)} occup√©s). Il n'y a plus de place pour {participant.full_name}. Veuillez choisir un AUTRE BUNGALOW avec des lits disponibles pour cette p√©riode.", {
            'code': 'BUNGALOW_FULL_FOR_PERIOD',
            'bungalow': bungalow.name,
            'capacity': bungalow.capacity,
            'occupied_count': len(occupied_beds_during_period),
            'period': f"{assignment_start.strftime('%d/%m')} - {assignment_end.strftime('%d/%m')}",
            'occupied_beds': list(occupied_beds_during_period)
        }
    
    # Toutes les validations sont pass√©es
    return True, None, None


def assign_participant_to_bungalow(
    participant: Participant,
    bungalow: Bungalow,
    bed_id: str,
    stage: Stage
) -> Tuple[bool, str, Optional[Dict]]:
    """
    Assigne un participant √† un bungalow en v√©rifiant toutes les r√®gles.
    
    Returns:
        Tuple[bool, str, Optional[Dict]]: (success, message, details)
    """
    
    # Valider l'assignation
    is_valid, error_message, error_details = validate_assignment(
        participant, bungalow, bed_id, stage
    )
    
    if not is_valid:
        return False, error_message, error_details
    
    # Obtenir les dates d'assignation
    assignment_start, assignment_end = get_participant_assignment_dates(participant, stage)
    
    # Effectuer l'assignation
    participant.assigned_bungalow = bungalow
    participant.assigned_bed = bed_id
    participant.assignment_start_date = assignment_start
    participant.assignment_end_date = assignment_end
    participant.save()
    
    # Mettre √† jour l'occupation du bungalow (pour la p√©riode actuelle)
    bungalow.update_occupancy()
    
    success_message = f"SUCC√àS: {participant.full_name} assign√© au bungalow {bungalow.name} (Village {bungalow.village.name}), lit {bed_id}, du {assignment_start} au {assignment_end} (Stage: {stage.name})"
    
    details = {
        'participant': participant.full_name,
        'bungalow': bungalow.name,
        'village': bungalow.village.name,
        'bed': bed_id,
        'start_date': str(assignment_start),
        'end_date': str(assignment_end),
        'stage': stage.name
    }
    
    return True, success_message, details


def get_bungalow_availability(bungalow: Bungalow, start_date: date, end_date: date) -> Dict:
    """
    Retourne la disponibilit√© d'un bungalow pour une p√©riode donn√©e.
    """
    occupied_beds = set()
    assignments = []
    
    # R√©cup√©rer tous les participants assign√©s pendant cette p√©riode
    participants_in_period = Participant.objects.filter(
        assigned_bungalow=bungalow,
        assignment_start_date__lte=end_date,
        assignment_end_date__gte=start_date
    )
    
    for p in participants_in_period:
        if p.assigned_bed:
            occupied_beds.add(p.assigned_bed)
            assignments.append({
                'participant': p.full_name,
                'bed': p.assigned_bed,
                'gender': p.get_gender_display(),
                'period': f"{p.assignment_start_date} - {p.assignment_end_date}",
                'stages': [s.name for s in p.stages.all()]
            })
    
    available_beds = []
    for bed in bungalow.beds:
        bed_id = bed.get('id')
        if bed_id not in occupied_beds:
            available_beds.append({
                'id': bed_id,
                'type': bed.get('type')
            })
    
    return {
        'bungalow': bungalow.name,
        'village': bungalow.village.name,
        'capacity': bungalow.capacity,
        'occupied_count': len(occupied_beds),
        'available_count': len(available_beds),
        'available_beds': available_beds,
        'current_assignments': assignments,
        'is_full': len(occupied_beds) >= bungalow.capacity
    }

